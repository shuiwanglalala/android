# Class 的基本语法

+ 简介
  + 类的由来
    + 基本上，ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已
    + 使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致
    + 构造函数的prototype属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面
    + 由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。Object.assign方法可以很方便地一次向类添加多个方法
    + 另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）
  + constructor 方法
    + constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加
    + constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象
    + 类必须使用new调用，否则会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行
  + 类的实例
    + 生成类的实例的写法，与 ES5 完全一样，也是使用new命令。前面说过，如果忘记加上new，像函数那样调用Class，将会报错
    + 与 ES5 一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）
    + 与 ES5 一样，类的所有实例共享一个原型对象。这也意味着，可以通过实例的__proto__属性为“类”添加方法
      + __proto__ 并不是语言本身的特性，这是各大厂商具体实现时添加的私有属性，虽然目前很多现代浏览器的 JS 引擎中都提供了这个私有属性，但依旧不建议在生产中使用该属性，避免对环境产生依赖。生产环境中，我们可以使用 Object.getPrototypeOf 方法来获取实例对象的原型，然后再来为原型添加方法/属性
  + 取值函数（getter）和存值函数（setter） 
    + 与 ES5 一样，在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为
    + 存值函数和取值函数是设置在属性的 Descriptor 对象上的
  + 属性表达式
    + 类的属性名，可以采用表达式
  + Class 表达式
    + 与函数一样，类也可以使用表达式的形式定义
    + 采用 Class 表达式，可以写出立即执行的 Class
  + 注意点
    + 严格模式
      + 类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。考虑到未来所有的代码，其实都是运行在模块之中，所以 ES6 实际上把整个语言升级到了严格模式
    + 不存在提升
    + name 属性
      + 由于本质上，ES6 的类只是 ES5 的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性
      + name属性总是返回紧跟在class关键字后面的类名
    + Generator 方法
      + 如果某个方法之前加上星号（*），就表示该方法是一个 Generator 函数
+ 静态方法
  + 类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”
  + 如果静态方法包含this关键字，这个this指的是类，而不是实例
  + 静态方法可以与非静态方法重名
  + 父类的静态方法，可以被子类继承
  + 静态方法也是可以从super对象上调用的
+ 实例属性的新写法
  + 实例属性除了定义在constructor()方法里面的this上面，也可以定义在类的最顶层
  + 这种新写法的好处是，所有实例对象自身的属性都定义在类的头部，看上去比较整齐，一眼就能看出这个类有哪些实例属性
+ 静态属性
  + 静态属性指的是 Class 本身的属性，即Class.propName，而不是定义在实例对象（this）上的属性
+ 私有方法和私有属性
+ new.target 属性