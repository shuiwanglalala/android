# Class 的继承

+ 简介
  + Class 可以通过extends关键字实现继承，这比 ES5 的通过修改原型链实现继承，要清晰和方便很多
  + 子类必须在constructor方法中调用super方法，否则新建实例时会报错
  + 如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法
  + 另一个需要注意的地方是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，基于父类实例，只有super方法才能调用父类实例
  + 最后，父类的静态方法，也会被子类继承
+ Object.getPrototypeOf()
+ super 关键字
  + super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同
    + 第一种情况，super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数
      + 作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错
    + 第二种情况，super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类
      + 这里需要注意，由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的
      + ES6 规定，在子类普通方法中通过super调用父类的方法时，方法内部的this指向当前的子类实例
      + 如果super作为对象，用在静态方法之中，这时super将指向父类，而不是父类的原型对象
      + 另外，在子类的静态方法中通过super调用父类的方法时，方法内部的this指向当前的子类，而不是子类的实例
  + 最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字
+ 类的 prototype 属性和__proto__属性
  + 大多数浏览器的 ES5 实现之中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。Class 作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链
    + 子类的__proto__属性，表示构造函数的继承，总是指向父类
    + 子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性
+ 原生构造函数的继承
+ Mixin 模式的实现