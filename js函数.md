# 函数

+ 概述
  + 函数的声明
    + function 命令
    + 将一个匿名函数赋值给变量。这时，这个匿名函数又称函数表达式（Function Expression），因为赋值语句的等号右侧只能放表达式
      + 采用函数表达式声明函数时，function命令后面不带有函数名
      + 如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效
        + 一是可以在函数体内部调用自身
        + 二是方便除错（除错工具显示函数调用栈时，将显示函数名，而不再显示这里是一个匿名函数）
    + Function 构造函数
      + 你可以传递任意数量的参数给Function构造函数，只有最后一个参数会被当做函数体，如果只有一个参数，该参数就是函数体
      + 这种声明函数的方式非常不直观，几乎无人使用
  + 函数的重复声明
    + 如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。由于函数名的提升，前一次声明在任何时候都是无效的
  + 圆括号运算符，return 语句和递归
  + 第一等公民
    + javaScript 语言将函数看作一种值，与其它值（数值、字符串、布尔值等等）地位相同。凡是可以使用值的地方，就能使用函数。比如，可以把函数赋值给变量和对象的属性，也可以当作参数传入其他函数，或者作为函数的结果返回。函数只是一个可以执行的值，此外并无特殊之处
  + 函数名的提升
    + JavaScript 引擎将函数名视同变量名，所以采用function命令声明函数时，整个函数会像变量声明一样，被提升到代码头部
    + 如果同时采用function命令和赋值语句声明同一个函数，最后总是采用赋值语句的定义
+ 函数的属性和方法
  + name 属性
    + 函数的name属性返回函数的名字
    + 如果是通过变量赋值定义的函数，那么name属性返回变量名
      + 但是，上面这种情况，只有在变量的值是一个匿名函数时才是如此。如果变量的值是一个具名函数，那么name属性返回function关键字之后的那个函数名
    + name属性的一个用处，就是获取参数函数的名字
  + length 属性
    + length属性提供了一种机制，判断定义时和调用时参数的差异，以便实现面向对象编程的“方法重载”（overload）
  + toString()
    + 函数的toString方法返回一个字符串，内容是函数的源码
    + 对于那些原生的函数，toString()方法返回function (){[native code]}
    + 函数内部的注释也可以返回
+ 函数作用域
  + 定义
    + ES5 的规范中，JavaScript 只有两种作用域
      + 一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取
      + 另一种是函数作用域，变量只在函数内部存在
    + ES6 又新增了块级作用域
    + 对于var命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量
  + 函数内部的变量提升
    + 与全局作用域一样，函数作用域内部也会产生“变量提升”现象。var命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部
  + 函数本身的作用域
    + 函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关
+ 参数
  + 概述
  + 参数的省略
    + 函数参数不是必需的，JavaScript 允许省略参数
    + 需要注意的是，函数的length属性与实际传入的参数个数无关，只反映函数预期传入的参数个数
    + 但是，没有办法只省略靠前的参数，而保留靠后的参数。如果一定要省略靠前的参数，只有显式传入undefined
  + 传递方式
    + 函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部
    + 但是，如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值
    + 注意，如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值
      + 注意，和java、kotlin的对比
  + 同名参数
    + 如果有同名的参数，则取最后出现的那个值
  + arguments 对象
    + 由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是arguments对象的由来。arguments对象包含了函数运行时的所有参数，arguments[0]就是第一个参数，arguments[1]就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用
    + 正常模式下，arguments对象可以在运行时修改
    + 严格模式下，arguments对象与函数参数不具有联动关系。也就是说，修改arguments对象不会影响到实际的函数参数
    + 通过arguments对象的length属性，可以判断函数调用时到底带几个参数
    + 需要注意的是，虽然arguments很像数组，但它是一个对象。数组专有的方法（比如slice和forEach），不能在arguments对象上直接使用
    + arguments对象带有一个callee属性，返回它所对应的原函数
      + 可以通过arguments.callee，达到调用函数自身的目的。这个属性在严格模式里面是禁用的，因此不建议使用
+ 函数的其他知识点
  + 闭包
    + 一个是可以读取函数内部的变量
    + 另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在
    + 闭包的另一个用处，是封装对象的私有属性和私有方法
    + 注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题
  + 立即调用的函数表达式（IIFE）
    + “立即调用的函数表达式”（Immediately-Invoked Function Expression），简称 IIFE
    + 有时，我们需要在定义函数之后，立即调用该函数。这时，你不能在函数的定义之后加上圆括号，这会产生语法错误。因为function这个关键字即可以当作语句，也可以当作表达式
      + 为了避免解析上的歧义，JavaScript 引擎规定，如果function关键字出现在行首，一律解释成语句
      + 若需要解析成表达式，最简单的处理，就是将其放在一个圆括号里面
    + 通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量
+ eval 命令
  + 基本用法
    + 接受一个字符串作为参数，并将这个字符串当作语句执行
    + 如果参数字符串无法当作语句运行，那么就会报错
    + 放在eval中的字符串，应该有独自存在的意义，不能用来与eval以外的命令配合使用
    + 如果eval的参数不是字符串，那么会原样返回
    + eval没有自己的作用域，都在当前作用域内执行，因此可能会修改当前作用域的变量的值，造成安全问题
      + 为了防止这种风险，JavaScript 规定，如果使用严格模式，eval内部声明的变量，不会影响到外部作用域
    + eval的本质是在当前作用域之中，注入代码。由于安全风险和不利于 JavaScript 引擎优化执行速度，所以一般不推荐使用。通常情况下，eval最常见的场合是解析 JSON 数据的字符串，不过正确的做法应该是使用原生的JSON.parse方法
  + eval 的别名调用
