# 函数

+ 概述
  + 函数的声明
    + function 命令
    + 将一个匿名函数赋值给变量。这时，这个匿名函数又称函数表达式（Function Expression），因为赋值语句的等号右侧只能放表达式
      + 采用函数表达式声明函数时，function命令后面不带有函数名
      + 如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效
        + 一是可以在函数体内部调用自身
        + 二是方便除错（除错工具显示函数调用栈时，将显示函数名，而不再显示这里是一个匿名函数）
    + Function 构造函数
      + 你可以传递任意数量的参数给Function构造函数，只有最后一个参数会被当做函数体，如果只有一个参数，该参数就是函数体
      + 这种声明函数的方式非常不直观，几乎无人使用
  + 函数的重复声明
    + 如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。由于函数名的提升，前一次声明在任何时候都是无效的
  + 圆括号运算符，return 语句和递归
  + 第一等公民
    + javaScript 语言将函数看作一种值，与其它值（数值、字符串、布尔值等等）地位相同。凡是可以使用值的地方，就能使用函数。比如，可以把函数赋值给变量和对象的属性，也可以当作参数传入其他函数，或者作为函数的结果返回。函数只是一个可以执行的值，此外并无特殊之处
  + 函数名的提升
    + JavaScript 引擎将函数名视同变量名，所以采用function命令声明函数时，整个函数会像变量声明一样，被提升到代码头部
    + 如果同时采用function命令和赋值语句声明同一个函数，最后总是采用赋值语句的定义
+ 函数的属性和方法
  + name 属性
    + 函数的name属性返回函数的名字
    + 如果是通过变量赋值定义的函数，那么name属性返回变量名
      + 但是，上面这种情况，只有在变量的值是一个匿名函数时才是如此。如果变量的值是一个具名函数，那么name属性返回function关键字之后的那个函数名
    + name属性的一个用处，就是获取参数函数的名字
  + length 属性
    + length属性提供了一种机制，判断定义时和调用时参数的差异，以便实现面向对象编程的“方法重载”（overload）
  + toString()
    + 函数的toString方法返回一个字符串，内容是函数的源码
    + 对于那些原生的函数，toString()方法返回function (){[native code]}
    + 函数内部的注释也可以返回
+ 函数作用域
  + 定义
    + ES5 的规范中，JavaScript 只有两种作用域
      + 一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取
      + 另一种是函数作用域，变量只在函数内部存在
    + ES6 又新增了块级作用域
    + 对于var命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量
  + 函数内部的变量提升
    + 与全局作用域一样，函数作用域内部也会产生“变量提升”现象。var命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部
  + 函数本身的作用域
    + 函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关
+ 参数
  + 概述
  + 参数的省略
    + 函数参数不是必需的，JavaScript 允许省略参数
    + 需要注意的是，函数的length属性与实际传入的参数个数无关，只反映函数预期传入的参数个数
    + 但是，没有办法只省略靠前的参数，而保留靠后的参数。如果一定要省略靠前的参数，只有显式传入undefined
  + 传递方式
    + 函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部
    + 但是，如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值
    + 注意，如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值
      + 注意，和java、kotlin的对比
  + 同名参数
    + 如果有同名的参数，则取最后出现的那个值
  + arguments 对象
    + 由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是arguments对象的由来。arguments对象包含了函数运行时的所有参数，arguments[0]就是第一个参数，arguments[1]就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用
    + 正常模式下，arguments对象可以在运行时修改
    + 严格模式下，arguments对象与函数参数不具有联动关系。也就是说，修改arguments对象不会影响到实际的函数参数
    + 通过arguments对象的length属性，可以判断函数调用时到底带几个参数
    + 需要注意的是，虽然arguments很像数组，但它是一个对象。数组专有的方法（比如slice和forEach），不能在arguments对象上直接使用
    + arguments对象带有一个callee属性，返回它所对应的原函数
      + 可以通过arguments.callee，达到调用函数自身的目的。这个属性在严格模式里面是禁用的，因此不建议使用
+ 函数的其他知识点
  + 闭包
    + 一个是可以读取函数内部的变量
    + 另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在
    + 闭包的另一个用处，是封装对象的私有属性和私有方法
    + 注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题
  + 立即调用的函数表达式（IIFE）
    + “立即调用的函数表达式”（Immediately-Invoked Function Expression），简称 IIFE
    + 有时，我们需要在定义函数之后，立即调用该函数。这时，你不能在函数的定义之后加上圆括号，这会产生语法错误。因为function这个关键字即可以当作语句，也可以当作表达式
      + 为了避免解析上的歧义，JavaScript 引擎规定，如果function关键字出现在行首，一律解释成语句
      + 若需要解析成表达式，最简单的处理，就是将其放在一个圆括号里面
    + 通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量
+ eval 命令
  + 基本用法
    + 接受一个字符串作为参数，并将这个字符串当作语句执行
    + 如果参数字符串无法当作语句运行，那么就会报错
    + 放在eval中的字符串，应该有独自存在的意义，不能用来与eval以外的命令配合使用
    + 如果eval的参数不是字符串，那么会原样返回
    + eval没有自己的作用域，都在当前作用域内执行，因此可能会修改当前作用域的变量的值，造成安全问题
      + 为了防止这种风险，JavaScript 规定，如果使用严格模式，eval内部声明的变量，不会影响到外部作用域
    + eval的本质是在当前作用域之中，注入代码。由于安全风险和不利于 JavaScript 引擎优化执行速度，所以一般不推荐使用。通常情况下，eval最常见的场合是解析 JSON 数据的字符串，不过正确的做法应该是使用原生的JSON.parse方法
  + eval 的别名调用















































+ 
+ 函数表达式
+ 调用函数
  + 函数提升仅适用于函数声明，而不适用于函数表达式
+ 函数作用域
  + 在函数内定义的变量不能在函数之外的任何地方访问，因为变量仅仅在该函数的域的内部有定义
  + 在另一个函数中定义的函数也可以访问在其父函数中定义的所有变量和父函数有权访问的任何其他变量
+ 作用域和函数堆栈
  + 递归
    + 函数名
    + arguments.callee
    + 作用域下的一个指向该函数的变量名
+ 嵌套函数和闭包
  + 内部函数只可以在外部函数中访问
  + 内部函数形成了一个闭包：它可以访问外部函数的参数和变量，但是外部函数却不能使用它的参数和变量
    + 外部函数的name变量对内嵌函数来说是可取得的，而除了通过内嵌函数本身，没有其它任何方法可以取得内嵌的变量。内嵌函数的内嵌变量就像内嵌函数的保险柜。它们会为内嵌函数保留“稳定”——而又安全——的数据参与运行。而这些内嵌函数甚至不会被分配给一个变量，或者不必一定要有名字
  + 由于内部函数形成了闭包，因此你可以调用外部函数并为外部函数和内部函数指定参数
  + 一个闭包必须保存它可见作用域中所有参数和变量。因为每一次调用传入的参数都可能不同，每一次对外部函数的调用实际上重新创建了一遍这个闭包。只有当返回的 inside 没有再被引用时，内存才会被释放。这与在其他对象中存储引用没什么不同，但是通常不太明显，因为并不能直接设置引用，也不能检查它们
  + 多层嵌套函数
    + 当同一个闭包作用域下两个参数或者变量同名时，就会产生命名冲突。更近的作用域有更高的优先权，所以最近的优先级最高，最远的优先级最低。这就是作用域链。链的第一个元素就是最里面的作用域，最后一个元素便是最外层的作用域
  + 如果一个闭包的函数定义了一个和外部函数的某个变量名称相同的变量，那么这个闭包将无法引用外部函数的这个变量
+ 使用 arguments 对象
  + 提示：arguments变量只是 ”类数组对象“，并不是一个数组。称其为类数组对象是说它有一个索引编号和length属性。尽管如此，它并不拥有全部的Array对象的操作方法
+ 函数参数
  + 默认参数
  + 剩余参数
+ 箭头函数
  + 箭头函数总是匿名的
  + 类似kotlin中的lambda函数