# let 和 const 命令

+ let 命令
  + 基本用法
    + ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效
    + for循环的计数器，就很合适使用let命令
      + 另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域
  + 不存在变量提升
    + let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错
  + 暂时性死区
    + 只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响
    + ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）
    + “暂时性死区”也意味着typeof不再是一个百分之百安全的操作
      + 所以，在没有let之前，typeof运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错
  + 不允许重复声明
    + let不允许在相同作用域内，重复声明同一个变量
+ 块级作用域
  + ES6 的块级作用域
    + let实际上为 JavaScript 新增了块级作用域
    + ES6 允许块级作用域的任意嵌套
    + 块级作用域的出现，实际上使得获得广泛应用的匿名立即执行函数表达式（匿名 IIFE）不再必要了
  + 块级作用域与函数声明
    + ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用
    + 考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句
    + 另外，还有一个需要注意的地方。ES6 的块级作用域必须有大括号，如果没有大括号，JavaScript 引擎就认为不存在块级作用域
+ const 命令
  + 基本用法
    + const声明一个只读的常量。一旦声明，常量的值就不能改变
    + const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值
    + const的作用域与let命令相同：只在声明所在的块级作用域内有效
    + const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用
    + const声明的常量，也与let一样不可重复声明
  + 本质
    + const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址所保存的数据不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针，const只能保证这个指针是固定的（即总是指向另一个固定的地址），至于它指向的数据结构是不是可变的，就完全不能控制了
  + ES6 声明变量的六种方法
    + ES5 只有两种声明变量的方法
      + var命令
      + function命令
    + ES6 添加了
      + let命令
      + const命令
      + import命令
      + class命令
+ 顶层对象的属性
  + 顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一
  + ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩
+ globalThis 对象