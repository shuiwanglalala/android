# 严格模式

+ 设计目的
+ 启用方法
  + 进入严格模式的标志，是一行字符串use strict
  + 放在脚本文件的第一行，整个脚本都将以严格模式运行
  + 放在函数体的第一行，则整个函数以严格模式运行
+ 显式报错
  + 只读属性不可写
    + 设置字符串的length属性，会报错
    + 对只读属性赋值，或者删除不可配置（non-configurable）属性都会报错
  + 只设置了取值器的属性不可写
    + 对一个只有取值器（getter）、没有存值器（setter）的属性赋值，会报错
  + 禁止扩展的对象不可扩展
  + eval、arguments 不可用作标识名
    + 使用eval或者arguments作为标识名，将会报错
  + 函数不能有重名的参数
    + 正常模式下，如果函数有多个重名的参数，可以用arguments[i]读取。严格模式下，这属于语法错误
  + 禁止八进制的前缀0表示法
+ 增强的安全措施
  + 全局变量显式声明
    + 正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。因此，严格模式下，变量都必须先声明，然后再使用
  + 禁止 this 关键字指向全局对象
    + 正常模式下，函数内部的this可能会指向全局对象，严格模式禁止这种用法，避免无意间创造全局变量
  + 禁止使用 fn.callee、fn.caller
  + 禁止使用 arguments.callee、arguments.caller
    + arguments.callee和arguments.caller是两个历史遗留的变量，从来没有标准化过，现在已经取消了。正常模式下调用它们没有什么作用，但是不会报错。严格模式明确规定，函数内部使用arguments.callee、arguments.caller将会报错
  + 禁止删除变量
    + 严格模式下无法删除变量，如果使用delete命令删除一个变量，会报错。只有对象的属性，且属性的描述对象的configurable属性设置为true，才能被delete命令删除
+ 静态绑定
  + JavaScript 语言的一个特点，就是允许“动态绑定”，即某些属性和方法到底属于哪一个对象，不是在编译时确定的，而是在运行时（runtime）确定的
  + 严格模式对动态绑定做了一些限制。某些情况下，只允许静态绑定。也就是说，属性和方法到底归属哪个对象，必须在编译阶段就确定。这样做有利于编译效率的提高，也使得代码更容易阅读，更少出现意外
    + 禁止使用 with 语句
      + 严格模式下，使用with语句将报错。因为with语句无法在编译时就确定，某个属性到底归属哪个对象，从而影响了编译效果
    + 创设 eval 作用域
      + 正常模式下，JavaScript 语言有两种变量作用域（scope）：全局作用域和函数作用域。严格模式创设了第三种作用域：eval作用域
      + 正常模式下，eval语句的作用域，取决于它处于全局作用域，还是函数作用域
      + 严格模式下，eval语句本身就是一个作用域，不再能够在其所运行的作用域创设新的变量了，也就是说，eval所生成的变量只能用于eval内部
    + arguments 不再追踪参数的变化
      + 变量arguments代表函数的参数。严格模式下，函数内部改变参数与arguments的联系被切断了，两者不再存在联动关系
+ 向下一个版本的 JavaScript 过渡
  + 非函数代码块不得声明函数
    + ES6 会引入块级作用域。为了与新版本接轨，ES5 的严格模式只允许在全局作用域或函数作用域声明函数。也就是说，不允许在非函数的代码块内声明函数
  + 保留字
    + 为了向将来 JavaScript 的新版本过渡，严格模式新增了一些保留字（implements、interface、let、package、private、protected、public、static、yield等）。使用这些词作为变量名将会报错