# 使用触摸手势

https://github.com/GcsSloop/AndroidNote



[Android事件分发机制一：事件是如何到达activity的？](https://juejin.cn/post/6918272111152726024#heading-0)

[Android事件分发机制二：核心分发逻辑源码解析](https://juejin.cn/post/6920883974952714247)

## 理解MotionEvent

一个完整的事件序列是从ACTION_DOWN开始，到ACTION_UP或者ACTION_CANCEL结束。 **一个手指**的完整序列是从ACTION_DOWN/ACTION_POINTER_DOWN开始，到ACTION_UP/ACTION_POINTER_UP/ACTION_CANCEL结束

- 一个MotionEvent对象内部使用一个数组来维护所有触控点的信息
- UP/DOWN类型的事件包含了触控点索引，可以根据该索引做出对应的操作
- 触控点的索引是变化的，不能作为跟踪的依据，而必须依据触控点id

首先需要知道事件分发的一个原则：**一个view消费了某一个触点的down事件后，该触点事件序列的后续事件，都由该view消费**

经过前面的描述我们知道，一个事件是包含所有触摸点的信息的。当viewGroup在派发事件时，每个触摸点的信息就需要分开分别发送给感兴趣的view，这就是事件分离

## ViewGroup对于事件的分发

### TouchTarget

TouchTarget中维护了每个子view以及所对应的触控点id，这里的id可以不止一个。TouchTarget本身是个链表，每个节点记录了子view所对应的触控点id。在viewGroup中，该链表的链表头是mFirstTouchTarget，如果他为null，表示没有任何子view接收了down事件

TouchTarget有个非常神奇的设计，他只使用一个整型变量来记录所有的触控id。整型变量中哪一个二进制位为1，则对应绑定该id的触控点

当一个down事件来临时，viewGroup会为这个down事件寻找适合的子view，并为他们创建一个TouchTarget加入到链表中。而当一个up事件来临时，viewGroup会把对应的TouchTarget节点信息删除

### 事件拦截

#### 安全拦截

安全拦截是一直被忽略的一种情况。当一个控件a被另一个非全屏控件b遮挡住的时候，那么有可能被恶意软件操作发生危险

#### 逻辑拦截

如果当前viewGroup中没有TouchTarget，而且这个事件不是down事件，这就意味着viewGroup自己消费了先前的down事件，那么这个事件就无须分发到子view必须自己消费，也就不需要拦截这种情况的事件。除此之外的事件都是需要分发到子view，那么viewGroup就可以对他们进行判断是否进行拦截。简单来说，**只有需要分发到子view的事件才需要拦截** 

判断是否拦截主要依靠两个因素：FLAG_DISALLOW_INTERCEPT标志和 `onInterceptTouchEvent()` 方法

+ 子view可以通过requestDisallowInterupt方法强制要求viewGroup不要拦截事件，viewGroup中会设置一个FLAG_DISALLOW_INTERCEPT标志表示不拦截事件。但是当前事件序列结束后，这个标志会被清除。如果需要的话需要再次调用requestDisallowInterupt方法进行设置
+ 如果子view没有强制要求不拦截，那么会调用`onInterceptTouchEvent()` 方法判断是否需要拦截。onInterceptTouchEvent方法默认只对一种特殊情况作了拦截。一般情况下我们会重写这个方法来拦截事件

### 寻找消费down事件的子控件

对于每一个down事件，不管是ACTION_DOWN还是ACTION_POINTER_DOWN，viewGroup都会优先在控件树中寻找合适的子控件来消费他。因为对于每一个down事件，标志着一个触控点的一个崭新的事件序列，viewGroup会尽自己的最大能力寻找合适的子控件。如果找不到合适的子控件，才会自己处理down事件

viewGroup寻找子控件的步骤也不复杂。首先viewGroup会为他的子控件构造一个控件列表，构造的顺序是view的绘制顺序的逆序，也就是一个view的z轴系数越高，显示高度越高，在列表的顺序就会越靠前

viewGroup会按顺序遍历整个列表，判断触控点的位置是否在该view的范围内、该view是否可以点击等，寻找合适的子view。如果找到合适的子view，则会把down事件分发给他，如果该view接收事件，则会为他创建一个TouchTarget，将该触控id和view进行绑定，之后该触控点的事件就可以直接分发给他了

而如果没有一个控件适合，那么会默认选取TouchTarget链表的最新一个节点。也就是当我们多点触控时，两次手指按下，如果没有找到合适的子view，那么就被认为是和上一个手指点击的是同个view

### 派发事件

经过了前面的寻找消费down事件子控件步骤，那么每个触控点都找到了消费自己事件序列的控件并绑定在了TouchTarget中；而如果没有找到合适的子控件，那么消费的对象就是viewGroup自己。因此派发事件的主要任务就是：**把不同触控点的信息分发给合适的viewGroup或touchTarget**

我们知道MotionEvent包含了当前屏幕所有触控点信息，而viewGroup的每个TouchTarget则包含了不同的view所感兴趣的触控点。 如果不需要进行事件分离，那么直接将当前的所有触控点的信息都发送给每个TouchTarget即可； 如果需要进行事件分离，那么会将MotionEvent中不同触控点的信息拆开分别创建新的MotionEvent，并发送给感兴趣的子控件； 如果TouchTarget链表为空，那么直接分发给viewGroup自己；所以touchTarget不为空的情况下，viewGroup自己是不会消费事件的，这也就意味着viewGroup和其中的view不会同时消费事件

在把原MotionEvent拆分成多个MotionEvent时，不仅需要把不同的触控点信息进行分离，还需要对坐标进行转换和改变事件类型

+ 我们接收到的触控点的位置信息并不是基于屏幕坐标系，而是基于当前view的坐标系。所以当viewGroup往子view分发事件时，需要把触控点的信息转换成对应view的坐标系
+ viewGroup收到的事件类型和子view收到的事件类型并不是完全一致的，在分发给子view的时候，viewGroup需要对事件类型进行修改，一般有以下情况需要修改：
  + viewGroup收到一个ACTION_POINTER_DOWN事件分发给一个子view，但是该子view前面没有收到其他的down事件，所以对于该view来说这是一个崭新的事件序列，所以需要把这个ACTION_POINTER_DOWN事件类型改为ACTION_DOWN再发送给子view
  + viewGroup收到一个ACTION_POINTER_DOWN或ACTION_POINTER_UP事件，假设这个事件类型对应触控点2，但是有一个子view他只对触控点1的事件序列感兴趣，那么在分离出触控点1的信息之后，还需要把事件类型改为ACTION_MOVE再分发给该子view

+ 注意，把原MotionEvent对象拆分为多个MotionEvent对象之后，触控点的索引也发生了改变，如果需要分发一个ACTION_POINTER_DOWN/UP事件给子view，那么需要注意更新触控点的索引值

## View对于事件的分发

+ 首先判断是否被其他非全屏view覆盖。这和上面viewGroup的安全性检查是一样的
+ 经过检查之后先检查是否有onTouchListener监听器，如果有则调用它
+ 如果第2步没有消费事件，那么会调用onTouchEvent方法来处理事件
  + 这个方法是view处理事件的核心，里面包含了点击、双击、长按等逻辑的处理需要重点关注

我们的操作模式有按键模式、触摸模式。按键模式对应的是外接键盘或者以前的老式键盘机，在按键模式下我们要点击一个按钮通常都是先使用方向光标选中一个button（也就是让该button获取到focus），然后再点击确认按下一个button。但是在触摸模式下，button却不需要获取焦点。**如果一个view在触摸模式下可以获取焦点，那么他将无法响应点击事件，也就是无法调用onClickListener监听器** ，例如EditTex

view辨别单击和长按的方法是**设置延时任务**，在源码中会看到很多的类似的代码，这里延时任务使用handler来实现。当一个down事件来临时，会添加一个延时任务到消息队列中。如果时间到还没有接收到up事件，说明这是个长按事件，那么就会调用onLongClickListener监听器，而如果在延时时间内收到了up事件，那么说明这是个单击事件，取消这个延时的任务，并调用onClickListener

另外，在默认的情况下，当我们按住一个view，然后手指滑动到该view所在的范围之外，那么系统会认为你对这个view已经不感兴趣，所以无法触发单击和长按事件。当然，很多时候并不是如此，这就需要具体的view来重写onTouchEvent逻辑了，但是view的默认实现是这样的逻辑

[Android事件分发机制三：事件分发工作流程](https://juejin.cn/post/6921238915143696392)

## 工作流程模型

### 事件序列被中断

1. 当viewGroup拦截子view的move或up事件之后，会将当前事件改为cancel事件并发送给子view
2. 如果当前事件序列还未结束，那些接下来的事件都会交给viewGroup的ouTouchEvent处理

### 多点触控情况

viewGroup在已有view接受了其他触点的down事件的情况下，另一个手指按下产生ACTION_POINTER_DOWN事件传递给viewGroup：

1. viewGroup会按照ACTION_DOWN的方式去分发ACTION_POINTER_DOWN事件
   - 如果子view消费该事件，那么和单点触控的流程一致
   - 如果子view未消费该事件，那么会交给上一个最后接收down事件的view去处理
2. viewGroup两个view接收了不同的down事件，那么拦截其中一个view的事件序列，viewGroup不会消费拦截的事件序列。换句话说，viewGroup和其中的view不能同时接收触摸事件

[Android事件分发机制四：学了事件分发有什么用？](https://juejin.cn/post/6922020192662863886)

[Android事件分发机制五：面试官你坐啊](https://juejin.cn/post/6922300686638153736)