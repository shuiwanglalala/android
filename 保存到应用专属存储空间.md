# 保存到应用专属存储空间

- **内部存储空间目录**：这些目录既包括用于存储持久性文件的专属位置，也包括用于存储缓存数据的其他位置。系统会阻止其他应用访问这些位置，并且在 Android 10（API 级别 29）及更高版本中，系统会对这些位置进行加密。这些特征使得这些位置非常适合存储只有应用本身才能访问的敏感数据
- **外部存储空间目录**：这些目录既包括用于存储持久性文件的专属位置，也包括用于存储缓存数据的其他位置。虽然其他应用可以在具有适当权限的情况下访问这些目录，但存储在这些目录中的文件仅供您的应用使用。如果您明确打算创建其他应用能够访问的文件，您的应用应改为将这些文件存储在外部存储空间的[共享存储空间](https://developer.android.com/training/data-storage/shared)部分

**注意**：如需进一步保护应用专属文件，请使用 [Android Jetpack](https://developer.android.com/jetpack) 中包含的 [Security 库](https://developer.android.com/topic/security/data)对这些静态文件进行加密。加密密钥专属于您的应用

## 从内部存储空间访问

对于每个应用，系统都会在内部存储空间中提供目录，应用可以在该存储空间中整理其文件。一个目录专为[应用的持久性文件](https://developer.android.com/training/data-storage/app-specific?hl=zh-cn#internal-access-files)而设计，而另一个目录包含[应用的缓存文件](https://developer.android.com/training/data-storage/app-specific?hl=zh-cn#internal-create-cache)。您的应用不需要任何系统权限即可读取和写入这些目录中的文件

其他应用无法访问存储在内部存储空间中的文件。这使得内部存储空间非常适合存储其他应用不应访问的应用数据

但是，请注意，这些目录的空间通常比较小。在将应用专属文件写入内部存储空间之前，应用应[查询设备上的可用空间](https://developer.android.com/training/data-storage/app-specific?hl=zh-cn#query-free-space)

### 访问持久性文件

#### 访问和存储文件

```java
File file = new File(context.getFilesDir(), filename);
```

#### 使用信息流存储文件

```java
String filename = "myfile";
String fileContents = "Hello world!";
try (FileOutputStream fos = context.openFileOutput(filename, Context.MODE_PRIVATE)) {
    fos.write(fileContents.toByteArray());
}
```

#### 使用信息流访问文件

如需以信息流的形式读取文件，请使用 [`openFileInput()`](https://developer.android.com/reference/android/content/Context?hl=zh-cn#openFileInput(java.lang.String))

如果在安装时需要以信息流的形式访问文件，请将文件保存在项目的 `/res/raw` 目录中。您可以使用 [`openRawResource()`](https://developer.android.com/reference/android/content/res/Resources?hl=zh-cn#openRawResource(int)) 打开这些文件，传入带有 `R.raw` 前缀的文件名作为资源 ID。此方法将返回一个 [`InputStream`](https://developer.android.com/reference/java/io/InputStream?hl=zh-cn)，您可以使用它读取文件。您无法写入原始文件

#### 查看文件列表

您可以通过调用 [`fileList()`](https://developer.android.com/reference/android/content/Context?hl=zh-cn#fileList()) 获取包含 `filesDir` 目录中所有文件名称的数组

### 创建缓存文件

如需创建缓存文件，请调用 [`File.createTempFile()`](https://developer.android.com/reference/java/io/File?hl=zh-cn#createTempFile(java.lang.String, java.lang.String))

```java
File.createTempFile(filename, null, context.getCacheDir());
```

您的应用会使用上下文对象的 [`cacheDir`](https://developer.android.com/reference/android/content/Context?hl=zh-cn#getCacheDir()) 属性和 [`File`](https://developer.android.com/reference/java/io/File?hl=zh-cn) API 访问此目录中的文件

```java
File cacheFile = new File(context.getCacheDir(), filename);
```

**注意**：当设备的内部存储空间不足时，Android 可能会删除这些缓存文件以回收空间。因此，请在读取前检查缓存文件是否存在

### 移除缓存文件

即使 Android 有时会自行删除缓存文件，您也不应依赖系统为您清理这些文件。您始终应该维护内部存储空间中的应用缓存文件

## 从外部存储空间访问

在 Android 4.4（API 级别 19）或更高版本中，应用无需请求任何与存储空间相关的权限即可访问外部存储空间中的应用专属目录。卸载应用后，系统会移除这些目录中存储的文件

**注意**：我们无法保证可以访问这些目录中的文件，例如从设备中取出可移除的 SD 卡后，就无法访问其中的文件。如果应用的功能取决于这些文件，应改为将文件存储在[内部存储空间](https://developer.android.com/training/data-storage/app-specific?hl=zh-cn#internal)中

在搭载 Android 9（API 级别 28）或更低版本的设备上，只要其他应用具有相应的存储权限，任何应用都可以访问外部存储空间中的应用专属文件。为了让用户更好地管理自己的文件并减少混乱，以 Android 10（API 级别 29）及更高版本为目标平台的应用在默认情况下被授予了对外部存储空间的分区访问权限（即[分区存储](https://developer.android.com/training/data-storage?hl=zh-cn#scoped-storage)）。启用分区存储后，应用将无法访问属于其他应用的应用专属目录

### 验证存储空间的可用性

由于外部存储空间位于用户可能能够移除的物理卷上，因此在尝试从外部存储空间读取应用专属数据或将应用专属数据写入外部存储空间之前，请验证该卷是否可访问。

您可以通过调用 [`Environment.getExternalStorageState()`](https://developer.android.com/reference/android/os/Environment?hl=zh-cn#getExternalStorageState()) 查询该卷的状态。如果返回的状态为 [`MEDIA_MOUNTED`](https://developer.android.com/reference/android/os/Environment?hl=zh-cn#MEDIA_MOUNTED)，那么您就可以在外部存储空间中读取和写入应用专属文件。如果返回的状态为 [`MEDIA_MOUNTED_READ_ONLY`](https://developer.android.com/reference/android/os/Environment?hl=zh-cn#MEDIA_MOUNTED_READ_ONLY)，您只能读取这些文件

### 选择物理存储位置

有时，分配内部存储分区作为外部存储空间的设备也会提供 SD 卡插槽。这意味着设备具有多个可能包含外部存储空间的物理卷，因此您需要选择用于应用专属存储空间的物理卷。

如需访问其他位置，请调用 [`ContextCompat.getExternalFilesDirs()`](https://developer.android.com/reference/androidx/core/content/ContextCompat?hl=zh-cn#getExternalFilesDirs(android.content.Context, java.lang.String))。如代码段中所示，返回数组中的第一个元素被视为主外部存储卷。除非该卷已满或不可用，否则请使用该卷

```java
File[] externalStorageVolumes =
        ContextCompat.getExternalFilesDirs(getApplicationContext(), null);
File primaryExternalStorage = externalStorageVolumes[0];
```

### 媒体内容

如果您的应用支持使用仅在您的应用内对用户有价值的媒体文件，最好将这些文件存储在外部存储空间中的应用专属目录中

## 查询可用空间

许多用户的设备上没有太多可用的存储空间，因此您的应用应谨慎使用空间。

如果您事先知道要存储的数据量，您可以通过调用 [`getAllocatableBytes()`](https://developer.android.com/reference/android/os/storage/StorageManager?hl=zh-cn#getAllocatableBytes(java.util.UUID)) 查出设备可以为应用提供多少空间。`getAllocatableBytes()` 的返回值可能大于设备上的当前可用空间量。这是因为系统已识别出可以从其他应用的缓存目录中移除的文件。

如果有足够的空间保存您的应用数据，请调用 [`allocateBytes()`](https://developer.android.com/reference/android/os/storage/StorageManager?hl=zh-cn#allocateBytes(java.io.FileDescriptor, long)) 声明空间。否则，应用可以调用包含 [`ACTION_MANAGE_STORAGE`](https://developer.android.com/reference/android/os/storage/StorageManager?hl=zh-cn#ACTION_MANAGE_STORAGE) 操作的 intent。此 intent 会向用户显示提示，要求他们在设备上选择要移除的文件，以便您的应用拥有所需空间

```java
// App needs 10 MB within internal storage.
private static final long NUM_BYTES_NEEDED_FOR_MY_APP = 1024 * 1024 * 10L;

StorageManager storageManager =
        getApplicationContext().getSystemService(StorageManager.class);
UUID appSpecificInternalDirUuid = storageManager.getUuidForPath(getFilesDir());
long availableBytes =
        storageManager.getAllocatableBytes(appSpecificInternalDirUuid);
if (availableBytes >= NUM_BYTES_NEEDED_FOR_MY_APP) {
    storageManager.allocateBytes(
            appSpecificInternalDirUuid, NUM_BYTES_NEEDED_FOR_MY_APP);
} else {
    Intent storageIntent = new Intent();
    storageIntent.setAction(ACTION_MANAGE_STORAGE);
    // Display prompt to user, requesting that they choose files to remove.
}
```

**注意**：您无需检查可用空间即可保存文件。您可以尝试立即写入文件，然后在出现 [`IOException`](https://developer.android.com/reference/java/io/IOException?hl=zh-cn) 时将其捕获。如果您不知道所需的确切空间量，则可能需要执行此操作