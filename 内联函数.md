# 内联函数

事实上，inline 关键字不止可以内联自己的内部代码，还可以内联自己内部的内部的代码。什么叫「内部的内部」？就是自己的函数类型的参数

如果你写的是高阶函数，会有函数类型的参数，加上 inline 就对了

所以，noinline 的作用是什么？是用来局部地、指向性地关掉函数的内联优化的。既然是优化，为什么要关掉？因为这种优化会导致函数中的函数类型的参数无法被当做对象使用

 Kotlin 制定了一条规则：Lambda 表达式里不允许使用 return，**除非——**这个 Lambda 是内联函数的参数

+ Lambda 里的 return，结束的不是直接的外层函数，而是外层再外层的函数
+ 但只有内联函数的 Lambda 参数可以使用 return
+ Kotlin 增加了一条额外规定：内联函数里被 crossinline 修饰的函数类型的参数，将不再享有「Lambda 表达式可以使用 return」的福利

所以什么时候需要 crossinline？当你需要突破内联函数的「不能间接调用参数」的限制的时候



inline 修饰符影响函数本身和传给它的 lambda 表达式：所有这些都将内联到调用处

内联可能导致生成的代码增加；不过如果我们使用得当（即避免内联过大函数），性能上会有所提升，尤其是在循环中的“超多态（megamorphic）”调用处

## 禁用内联

如果希望只内联一部分传给内联函数的 lambda 表达式参数，那么可以用 noinline 修饰符标记不希望内联的函数参数

可以内联的 lambda 表达式只能在内联函数内部调用或者作为可内联的参数传递， 但是 `noinline` 的可以以任何我们喜欢的方式操作：存储在字段中、传送它等等

需要注意的是，如果一个内联函数没有可内联的函数参数并且没有具体化的类型参数，编译器会产生一个警告，因为内联这样的函数很可能并无益处（如果你确认需要内联，则可以用 @Suppress("NOTHING_TO_INLINE") 注解关掉该警告）

## 非局部返回

+ 在 Kotlin 中，我们只能对具名或匿名函数使用正常的、非限定的 return 来退出。 这意味着要退出一个 lambda 表达式，我们必须使用一个标签，并且在 lambda 表达式内部禁止使用裸 return，因为 lambda 表达式不能使包含它的函数返回
+ 但是如果 lambda 表达式传给的函数是内联的，该 return 也可以内联，所以它是允许的。这种返回（位于 lambda 表达式中，但退出包含它的函数）称为非局部返回。 我们习惯了在循环中用这种结构

**请注意，一些内联函数可能调用传给它们的不是直接来自函数体、而是来自另一个执行上下文的 lambda 表达式参数，例如来自局部对象或嵌套函数。在这种情况下，该 lambda 表达式中也不允许非局部控制流。为了标识这种情况，该 lambda 表达式参数需要用 crossinline 修饰符标记 **

## 具体化的类型参数 ？？？

## 内联属性 ？？？

## 公有 API 内联函数的限制？？

# Java

[JAVA中的内联函数](https://www.cnblogs.com/zhaoxinshanwei/p/8136651.html)

TIJ 7.8.2

+ 考虑效率而final方法，已被劝阻，jvm会做效率优化