# 内联类

内联类必须含有唯一的一个属性在主构造函数中初始化。在运行时，将使用这个唯一属性来表示内联类的实例

## 成员

内联类支持普通类中的一些功能。特别是，内联类可以声明属性与函数

然而，内联类的成员也有一些限制：

- 内联类不能含有 *init* 代码块

- 内联类不能含有

  幕后字段

  - 因此，内联类只能含有简单的计算属性（不能含有延迟初始化/委托属性）

## 继承

内联类允许去继承接口

禁止内联类参与到类的继承关系结构中。这就意味着内联类不能继承其他的类而且必须是 *final*

## 表示方式

在生成的代码中，Kotlin 编译器为每个内联类保留一个包装器。内联类的实例可以在运行时表示为包装器或者基础类型。这就类似于 `Int` 可以[表示](https://www.kotlincn.net/docs/reference/basic-types.html#表示方式)为原生类型 `int` 或者包装器 `Integer`

为了生成性能最优的代码，Kotlin 编译更倾向于使用基础类型而不是包装器。 然而，有时候使用包装器是必要的。一般来说，只要将内联类用作另一种类型，它们就会被装箱

因为内联类既可以表示为基础类型有可以表示为包装器，[引用相等](https://www.kotlincn.net/docs/reference/equality.html#引用相等)对于内联类而言毫无意义，因此这也是被禁止的

### 名字修饰

由于内联类被编译为其基础类型，因此可能会导致各种模糊的错误，例如意想不到的平台签名冲突

为了缓解这种问题，一般会通过在函数名后面拼接一些稳定的哈希码来重命名函数

请注意在 Java 中 `-` 是一个 *无效的* 符号，也就是说在 Java 中不能调用使用内联类作为形参的函数

## 内联类与类型别名

初看起来，内联类似乎与[类型别名](https://www.kotlincn.net/docs/reference/type-aliases.html)非常相似。实际上，两者似乎都引入了一种新的类型，并且都在运行时表示为基础类型

然而，关键的区别在于类型别名与其基础类型(以及具有相同基础类型的其他类型别名)是 *赋值兼容* 的，而内联类却不是这样

换句话说，内联类引入了一个真实的新类型，与类型别名正好相反，类型别名仅仅是为现有的类型取了个新的替代名称(别名)