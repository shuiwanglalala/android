# 函数

+ 函数表达式
+ 调用函数
  + 函数提升仅适用于函数声明，而不适用于函数表达式
+ 函数作用域
  + 在函数内定义的变量不能在函数之外的任何地方访问，因为变量仅仅在该函数的域的内部有定义
  + 在另一个函数中定义的函数也可以访问在其父函数中定义的所有变量和父函数有权访问的任何其他变量
+ 作用域和函数堆栈
  + 递归
    + 函数名
    + arguments.callee
    + 作用域下的一个指向该函数的变量名
+ 嵌套函数和闭包
  + 内部函数只可以在外部函数中访问
  + 内部函数形成了一个闭包：它可以访问外部函数的参数和变量，但是外部函数却不能使用它的参数和变量
    + 外部函数的name变量对内嵌函数来说是可取得的，而除了通过内嵌函数本身，没有其它任何方法可以取得内嵌的变量。内嵌函数的内嵌变量就像内嵌函数的保险柜。它们会为内嵌函数保留“稳定”——而又安全——的数据参与运行。而这些内嵌函数甚至不会被分配给一个变量，或者不必一定要有名字
  + 由于内部函数形成了闭包，因此你可以调用外部函数并为外部函数和内部函数指定参数
  + 一个闭包必须保存它可见作用域中所有参数和变量。因为每一次调用传入的参数都可能不同，每一次对外部函数的调用实际上重新创建了一遍这个闭包。只有当返回的 inside 没有再被引用时，内存才会被释放。这与在其他对象中存储引用没什么不同，但是通常不太明显，因为并不能直接设置引用，也不能检查它们
  + 多层嵌套函数
    + 当同一个闭包作用域下两个参数或者变量同名时，就会产生命名冲突。更近的作用域有更高的优先权，所以最近的优先级最高，最远的优先级最低。这就是作用域链。链的第一个元素就是最里面的作用域，最后一个元素便是最外层的作用域
  + 如果一个闭包的函数定义了一个和外部函数的某个变量名称相同的变量，那么这个闭包将无法引用外部函数的这个变量
+ 使用 arguments 对象
  + 提示：arguments变量只是 ”类数组对象“，并不是一个数组。称其为类数组对象是说它有一个索引编号和length属性。尽管如此，它并不拥有全部的Array对象的操作方法
+ 函数参数
  + 默认参数
  + 剩余参数
+ 箭头函数
  + 箭头函数总是匿名的
  + 类似kotlin中的lambda函数