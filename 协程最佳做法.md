# 在 Android 中使用协程的最佳做法

## 注入调度程序

在创建新协程或调用 `withContext` 时，请勿对 `Dispatchers` 进行硬编码

## ViewModel 应创建协程

[`ViewModel`](https://developer.android.com/topic/libraries/architecture/viewmodel) 类应首选创建协程，而不是公开挂起函数来执行业务逻辑。如果只需要发出一个值，而不是使用数据流公开状态，`ViewModel` 中的挂起函数就会非常有用

视图不应直接触发任何协程来执行业务逻辑，而应将这项工作委托给 `ViewModel`

## 不要公开可变类型

最好向其他类公开不可变类型。这样一来，对可变类型的所有更改都会集中在一个类中，便于在出现问题时进行调试

## 数据层和业务层应公开挂起函数和数据流

数据层和业务层中的类通常会公开函数以执行一次性调用，或接收数据随时间变化的通知。这些层中的类应该**针对一次性调用公开挂起函数**，并**公开数据流以接收关于数据更改的通知**

### 在业务层和数据层中创建协程

如果仅当用户查看当前屏幕时，要在这些协程中完成的工作才具有相关性，则应遵循调用方的生命周期。在大多数情况下，调用方将是 ViewModel。在这种情况下，应使用 [`coroutineScope`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/coroutine-scope.html) 或 [`supervisorScope`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/supervisor-scope.html)

如果只要应用处于打开状态，要完成的工作就具有相关性，并且此工作不限于特定屏幕，那么此工作的存在时间应该比调用方的生命周期更长。对于这种情况，您应使用外部 `CoroutineScope`

`externalScope` 应由存在时间比当前屏幕更长的类进行创建和管理，并且可由 `Application` 类或作用域限定为导航图的 `ViewModel` 进行管理

## 避免使用 GlobalScope

## 将协程设为可取消

协程取消属于协作操作，也就是说，在协程的 `Job` 被取消后，相应协程在挂起或检查是否存在取消操作之前不会被取消。如果您在协程中执行阻塞操作，请确保相应协程是可取消的

若要检查是否存在取消操作，有一种方法是调用 [`ensureActive`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/ensure-active.html) 函数

`kotlinx.coroutines` 中的所有挂起函数（例如 `withContext` 和 `delay`）都是可取消的。如果您的协程调用这些函数，您无需执行任何其他操作

## 留意异常

不当处理协程中抛出的异常可能导致您的应用崩溃。如果可能会发生异常，请在使用 `viewModelScope` 或 `lifecycleScope` 创建的任何协程内容中捕获相应异常