# 利用 Kotlin 协程提升应用性能

## 管理长时间运行的任务

协程在常规函数的基础上添加了两项操作，用于处理长时间运行的任务。在 `invoke`（或 `call`）和 `return` 之外，协程添加了 `suspend` 和 `resume`

- `suspend` 用于暂停执行当前协程，并保存所有局部变量
- `resume` 用于让已挂起的协程从挂起处继续执行

Kotlin 使用堆栈帧管理要运行哪个函数以及所有局部变量。挂起协程时，系统会复制并保存当前的堆栈帧以供稍后使用。恢复时，会将堆栈帧从其保存位置复制回来，然后函数再次开始运行。即使代码可能看起来像普通的顺序阻塞请求，协程也能确保网络请求避免阻塞主线程

## 使用协程确保主线程安全

### withContext() 的效用

与基于回调的等效实现相比，[`withContext()`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html) 不会增加额外的开销

## 启动协程

您可以通过以下两种方式来启动协程：

- [`launch`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html) 可启动新协程而不将结果返回给调用方。任何被视为“一劳永逸”的工作都可以使用 `launch` 来启动
- [`async`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html)会启动一个新的协程，并允许您使用一个名为 `await` 的挂起函数返回结果

**警告**：`launch` 和 `async` 处理异常的方式不同。由于 `async` 希望在某一时刻对 `await` 进行最终调用，因此它持有异常并将其作为 `await` 调用的一部分重新抛出。这意味着，如果您使用 `async` 从常规函数启动新协程，则能以静默方式丢弃异常。这些丢弃的异常不会出现在崩溃指标中，也不会在 logcat 中注明

## 协程概念

### CoroutineScope

[`CoroutineScope`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/) 会跟踪它使用 `launch` 或 `async` 创建的所有协程。您可以随时调用 `scope.cancel()` 以取消正在进行的工作（即正在运行的协程）。在 Android 中，某些 KTX 库为某些生命周期类提供自己的 `CoroutineScope`。例如，`ViewModel` 有 [`viewModelScope`](https://developer.android.com/reference/kotlin/androidx/lifecycle/package-summary#(androidx.lifecycle.ViewModel).viewModelScope:kotlinx.coroutines.CoroutineScope)，`Lifecycle` 有 [`lifecycleScope`](https://developer.android.com/reference/kotlin/androidx/lifecycle/package-summary#lifecyclescope)。不过，与调度程序不同，`CoroutineScope` 不运行协程

如果您需要创建自己的 `CoroutineScope` 以控制协程在应用的特定层中的生命周期，则可以创建一个如下所示的 CoroutineScope

```kotlin
class ExampleClass {

    // Job and Dispatcher are combined into a CoroutineContext which
    // will be discussed shortly
    val scope = CoroutineScope(Job() + Dispatchers.Main)

    fun exampleMethod() {
        // Starts a new coroutine within the scope
        scope.launch {
            // New coroutine that can call suspend functions
            fetchDocs()
        }
    }

    fun cleanUp() {
        // Cancel the scope to cancel ongoing coroutines work
        scope.cancel()
    }
}
```

已取消的作用域无法再创建协程。因此，仅当控制其生命周期的类被销毁时，才应调用 `scope.cancel()`。使用 `viewModelScope` 时，[`ViewModel`](https://developer.android.com/topic/libraries/architecture/viewmodel) 类会在 ViewModel 的 `onCleared()` 方法中自动为您取消作用域

### 作业

[`Job`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html) 是协程的句柄。使用 `launch` 或 `async` 创建的每个协程都会返回一个 `Job` 实例，该实例是相应协程的唯一标识并管理其生命周期。您还可以将 `Job` 传递给 `CoroutineScope` 以进一步管理其生命周期

### CoroutineContext

[`CoroutineContext`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-coroutine-context/index.html) 使用以下元素集定义协程的行为：

- [`Job`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html)：控制协程的生命周期
- [`CoroutineDispatcher`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/index.html)：将工作分派到适当的线程
- [`CoroutineName`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-name/index.html)：协程的名称，可用于调试
- [`CoroutineExceptionHandler`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-exception-handler/index.html)：处理未捕获的异常

对于在作用域内创建的新协程，系统会为新协程分配一个新的 `Job` 实例，而从包含作用域继承其他 `CoroutineContext` 元素。可以通过向 `launch` 或 `async` 函数传递新的 `CoroutineContext` 替换继承的元素。请注意，将 `Job` 传递给 `launch` 或 `async` 不会产生任何效果，因为系统始终会向新协程分配 `Job` 的新实例