# 对象的继承

+ 原型对象概述
  + 构造函数的缺点
  + prototype 属性的作用
    + JavaScript 继承机制的设计思想就是，原型对象的所有属性和方法，都能被实例对象共享。也就是说，如果属性和方法定义在原型上，那么所有实例对象就能共享，不仅节省了内存，还体现了实例对象之间的联系
    + 每个函数都有一个prototype属性
      + 对于普通函数来说，该属性基本无用
      + 对于构造函数来说，生成实例的时候，该属性会自动成为实例对象的原型
        + 原型对象的属性不是实例对象自身的属性。只要修改原型对象，变动就立刻会体现在所有实例对象上
        + 如果实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法
  + 原型链
    + JavaScript 规定，所有对象都有自己的原型对象（prototype）。一方面，任何一个对象，都可以充当其他对象的原型
    + 那么，Object.prototype对象有没有它的原型呢？回答是Object.prototype的原型是null。null没有任何属性和方法，也没有自己的原型。因此，原型链的尽头就是null
    + 读取对象的某个属性时，JavaScript 引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的Object.prototype还是找不到，则返回undefined。如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”（overriding）
    + 注意，一级级向上，在整个原型链上寻找某个属性，对性能是有影响的。所寻找的属性在越上层的原型对象，对性能的影响越大。如果寻找某个不存在的属性，将会遍历整个原型链
  + constructor 属性
    + prototype对象有一个constructor属性，默认指向prototype对象所在的构造函数
      + constructor属性的作用是，可以得知某个实例对象，到底是哪一个构造函数产生的
      + 有了constructor属性，就可以从一个实例对象新建另一个实例
    + constructor属性表示原型对象与构造函数之间的关联关系，如果修改了原型对象，一般会同时修改constructor属性，防止引用的时候出错
      + 只在原型对象上添加方法，这样可以保证instanceof运算符不会失真
    + 如果不能确定constructor属性是什么函数，还有一个办法：通过name属性，从实例得到构造函数的名称
+ instanceof 运算符
  + instanceof运算符返回一个布尔值，表示对象是否为某个构造函数的实例
  + instanceof运算符的左边是实例对象，右边是构造函数。它会检查右边构建函数的原型对象（prototype），是否在左边对象的原型链上
  + 由于instanceof检查整个原型链，因此同一个实例对象，可能会对多个构造函数都返回true
  + 由于任意对象（除了null）都是Object的实例，所以instanceof运算符可以判断一个值是否为非null的对象
  + instanceof运算符的一个用处，是判断值的类型
    + 但是，只要一个对象的原型不是null，instanceof运算符的判断就不会失真
    + instanceof运算符只能用于对象，不适用原始类型的值
    + 对于undefined和null，instanceof运算符总是返回false
+ 构造函数的继承
  + 第一步是在子类的构造函数中，调用父类的构造函数
  + 第二步，是让子类的原型指向父类的原型，这样子类就可以继承父类原型
+ 多重继承
+ 模块
  + 基本的实现方法
  + 封装私有变量：构造函数的写法
  + 封装私有变量：立即执行函数的写法
  + 模块的放大模式
  + 输入全局变量