# 对象表达式与对象声明

有时候，我们需要创建一个对某个类做了轻微改动的类的对象，而不用为之显式声明新的子类。 Kotlin 用*对象表达式*和*对象声明*处理这种情况

## 对象表达式

要创建一个继承自某个（或某些）类型的匿名类的对象

如果超类型有一个构造函数，则必须传递适当的构造函数参数给它。 多个超类型可以由跟在冒号后面的逗号分隔的列表指定

请注意，匿名对象可以用作只在本地和私有作用域中声明的类型。如果你使用匿名对象作为公有函数的返回类型或者用作公有属性的类型，那么该函数或属性的实际类型会是匿名对象声明的超类型，如果你没有声明任何超类型，就会是 `Any`。在匿名对象中添加的成员将无法访问

对象表达式中的代码可以访问来自包含它的作用域的变量

## 对象声明

这称为*对象声明*。并且它总是在 *object* 关键字后跟一个名称。 就像变量声明一样，对象声明不是一个表达式，不能用在赋值语句的右边

对象声明的初始化过程是线程安全的并且在首次访问时进行

如需引用该对象，我们直接使用其名称即可

对象声明不能在局部作用域（即直接嵌套在函数内部），但是它们可以嵌套到其他对象声明或非内部类中

### 伴生对象

类内部的对象声明可以用 *companion* 关键字标记

该伴生对象的成员可通过只使用类名作为限定符来调用

可以省略伴生对象的名称，在这种情况下将使用名称 `Companion`

其自身所用的类的名称（不是另一个名称的限定符）可用作对该类的伴生对象 （无论是否具名）的引用

请注意，即使伴生对象的成员看起来像其他语言的静态成员，在运行时他们仍然是真实对象的实例成员，而且，例如还可以实现接口

当然，在 JVM 平台，如果使用 `@JvmStatic` 注解，你可以将伴生对象的成员生成为真正的静态方法和字段

### 对象表达式和对象声明之间的语义差异

对象表达式和对象声明之间有一个重要的语义差别

- 对象表达式是在使用他们的地方**立即**执行（及初始化）的
- 对象声明是在第一次被访问到时**延迟**初始化的
- 伴生对象的初始化是在相应的类被加载（解析）时，与 Java 静态初始化器的语义相匹配



那在实际使用中，在 `object`、`companion object` 和 top-level 中该选择哪一个呢？简单来说按照下面这两个原则判断

- 如果想写工具类的功能，直接创建文件，写 top-level「顶层」函数
- 如果需要继承别的类或者实现接口，就用 `object` 或 `companion object`