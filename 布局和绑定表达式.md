# 布局和绑定表达式

## 数据对象

用于 [`android:text`](https://developer.android.com/reference/android/widget/TextView#attr_android:text) 特性的表达式 `@{user.firstName}` 访问前一个类中的 `firstName` 字段和后一个类中的 `getFirstName()` 方法。或者，如果该方法存在，也将解析为 `firstName()`

## 表达式语言

### 属性引用

表达式可以使用以下格式在类中引用属性，这对于字段、getter 和 [`ObservableField`](https://developer.android.com/reference/androidx/databinding/ObservableField) 对象都一样

```
android:text="@{user.lastName}"
```

### Null 合并运算符

如果左边运算数不是 `null`，则 Null 合并运算符 (`??`) 选择左边运算数，如果左边运算数为 `null`，则选择右边运算数

类似Kotlin中的(`?:`)

### 避免出现 Null 指针异常

生成的数据绑定代码会自动检查有没有 `null` 值并避免出现 Null 指针异常。例如，在表达式 `@{user.name}` 中，如果 `user` 为 Null，则为 `user.name` 分配默认值 `null`。如果您引用 `user.age`，其中 age 的类型为 `int`，则数据绑定使用默认值 `0`

### 视图引用

表达式可以通过以下语法按 ID 引用布局中的其他视图

**注意**：绑定类将 ID 转换为驼峰式大小写

```xml
<EditText
        android:id="@+id/example_text"
        android:layout_height="wrap_content"
        android:layout_width="match_parent"/>
    <TextView
        android:id="@+id/example_output"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:text="@{exampleText.text}"/>
```

### 集合

为方便起见，可使用 `[]` 运算符访问常见集合，例如数组、列表、稀疏列表和映射

**注意**：要使 XML 不含语法错误，您必须转义 `<` 字符。例如：不要写成 `List` 形式，而是必须写成 `List<String>`

您还可以使用 `object.key` 表示法在映射中引用值。例如，以上示例中的 `@{map[key]}` 可替换为 `@{map.key}`

### 字符串字面量

您可以使用单引号括住特性值，这样就可以在表达式中使用双引号

也可以使用双引号括住特性值。如果这样做，则还应使用反单引号 ``` 将字符串字面量括起来

### 资源

## 事件处理

- [方法引用](https://developer.android.com/topic/libraries/data-binding/expressions#method_references)：在表达式中，您可以引用符合监听器方法签名的方法。当表达式求值结果为方法引用时，数据绑定会将方法引用和所有者对象封装到监听器中，并在目标视图上设置该监听器。如果表达式的求值结果为 `null`，则数据绑定不会创建监听器，而是设置 `null` 监听器
- [监听器绑定](https://developer.android.com/topic/libraries/data-binding/expressions#listener_bindings)：这些是在事件发生时进行求值的 lambda 表达式。数据绑定始终会创建一个要在视图上设置的监听器。事件被分派后，监听器会对 lambda 表达式进行求值

### 方法引用

与 `View` `onClick` 特性相比，一个主要优点是表达式在编译时进行处理，因此，如果该方法不存在或其签名不正确，则会收到编译时错误

**注意**：表达式中的方法签名必须与监听器对象中的方法签名完全一致

### 监听器绑定

在方法引用中，方法的参数必须与事件监听器的参数匹配。在监听器绑定中，只有您的返回值必须与监听器的预期返回值相匹配（预期返回值无效除外）

在表达式中使用回调时，数据绑定会自动为事件创建并注册必要的监听器。当视图触发事件时，数据绑定会对给定表达式求值。与常规绑定表达式一样，在对这些监听器表达式求值时，仍会获得数据绑定的 Null 值和线程安全

监听器绑定提供两个监听器参数选项：您可以忽略方法的所有参数，也可以命名所有参数。如果您想命名参数，则可以在表达式中使用这些参数

如果由于 `null` 对象而无法对表达式求值，则数据绑定将返回该类型的默认值。例如，引用类型返回 `null`，`int` 返回 `0`，`boolean` 返回 `false`，等等

如果您需要将表达式与谓词（例如，三元运算符）结合使用，则可以使用 `void` 作为符号

```xml
android:onClick="@{(v) -> v.isVisible() ? doSomething() : void}"
```

## 导入、变量和包含

### 导入

在表达式中引用静态字段和方法时，也可以使用导入的类型

### 变量

变量类型在编译时进行检查，因此，如果变量实现 [`Observable`](https://developer.android.com/reference/androidx/databinding/Observable) 或者是[可观察集合](https://developer.android.com/topic/libraries/data-binding/observability#observable_collections)，则应反映在类型中。如果该变量是不实现 `Observable` 接口的基类或接口，则变量是“不可观察的”

如果不同配置（例如横向或纵向）有不同的布局文件，则变量会合并在一起。这些布局文件之间不得存在有冲突的变量定义

在生成的绑定类中，每个描述的变量都有一个对应的 setter 和 getter。在调用 setter 之前，这些变量一直采用默认的托管代码值，例如引用类型采用 `null`，`int` 采用 `0`，`boolean` 采用 `false`，等等

系统会根据需要生成名为 `context` 的特殊变量，用于绑定表达式。`context` 的值是根视图的 `getContext()` 方法中的 `Context` 对象。`context` 变量会被具有该名称的显式变量声明替换 ？？

### 包含

通过使用应用命名空间和特性中的变量名称，变量可以从包含的布局传递到被包含布局的绑定

数据绑定不支持 include 作为 merge 元素的直接子元素