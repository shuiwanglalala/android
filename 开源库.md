# 开源库

Glide

+ 多种图片格式的缓存，适用于更多的内容表现形式（如Gif、WebP、缩略图、Video）
  生命周期集成（根据Activity或者Fragment的生命周期管理图片加载请求）
  高效处理Bitmap（bitmap的复用和主动回收，减少系统回收压力）
  高效的缓存策略，灵活（Picasso只会缓存原始尺寸的图片，Glide缓存的是多种规格），加载速度快且内存开销小（默认Bitmap格式的不同，使得内存开销是Picasso的一半）

+ -没有文件缓存 -java heap比Fresco高

Fresco

+ 最大的优势在于5.0以下(最低2.3)的bitmap加载。在5.0以下系统，Fresco将图片放到一个特别的内存区域(Ashmem区)
  大大减少OOM（在更底层的Native层对OOM进行处理，图片将不再占用App的内存）
  适用于需要高性能加载大量图片的场景

+ 包较大（2~3M）
  用法复杂
  底层涉及c++领域，阅读源码深入学习难度大

+ Retrofit

Retrofit就是一个网络请求框架的封装，底层的网络请求默认使用的Okhttp，本身只是简化了用户网络请求的参数配置等，还能与Rxjava相结合，使用起来更加简洁方便

App应用程序通过Retrofit请求网络，实际上是使用Retrofit接口层封装请求参数，之后由OkHttp完成后续的请求操作
在服务端返回数据之后，OkHttp将原始的结果交给Retrofit，Retrofit根据用户的需求对结果进行解析
完成数据的转化(converterFactory)，适配(callAdapterFactory)，通过设计模式进行各种扩展

+ 协程

协程中「挂起」的对象到底是什么？挂起线程，还是挂起函数？都不对，我们挂起的对象是协程。

还记得协程是什么吗？启动一个协程可以使用 launch 或者 async 函数，协程其实就是这两个函数中闭包的代码块。

launch ，async 或者其他函数创建的协程，在执行到某一个 suspend 函数的时候，这个协程会被「suspend」，也就是被挂起。

那此时又是从哪里挂起？从当前线程挂起。换句话说，就是这个协程从正在执行它的线程上脱离

线程的代码在到达 suspend 函数的时候被掐断，接下来协程会从这个 suspend 函数开始继续往下执行，不过是在指定的线程。紧接着在 suspend 函数执行完成之后，协程为我们做的最爽的事就来了：会自动帮我们把线程再切回来

不过区别在于，挂起函数在执行完成之后，协程会重新切回它原先的线程。

再简单来讲，在 Kotlin 中所谓的挂起，就是一个稍后会被自动切回来的线程调度操作

所以我们想要自己写一个挂起函数，仅仅只加上 suspend 关键字是不行的，还需要函数内部直接或间接地调用到 Kotlin 协程框架自带的 suspend 函数才行

挂起的非阻塞式指的是它能用看起来阻塞的代码写出非阻塞的操作，就这么简单

(1)RxJava堆栈可读性差，一旦出现问题，堆栈信息爆炸，难以定位问题，而协程就可以避免这个问题

(2)协程用同步的方式写异步的代码，美好了生活，方便代码阅读

(3)协程学习曲线比较平坦，相对于RxJava，协程对初学者更易于学习