# 扩展

## 扩展函数

声明一个扩展函数，我们需要用一个 *接收者类型* 也就是被扩展的类型来作为他的前缀

这个 *this* 关键字在扩展函数内部对应到接收者对象（传过来的在点符号前的对象）

## 扩展是静态解析的

扩展不能真正的修改他们所扩展的类。通过定义一个扩展，你并没有在一个类中插入新成员， 仅仅是可以通过该类型的变量用点表达式去调用这个新函数

我们想强调的是扩展函数是静态分发的，即他们不是根据接收者类型的虚方法。 这意味着调用的扩展函数是由函数调用所在的表达式的类型来决定的， 而不是由表达式运行时求值结果决定的

如果一个类定义有一个成员函数与一个扩展函数，而这两个函数又有相同的接收者类型、 相同的名字，并且都适用给定的参数，这种情况**总是取成员函数**

当然，扩展函数重载同样名字但不同签名成员函数也完全可以

## 可空接收者

注意可以为可空的接收者类型定义扩展。这样的扩展可以在对象变量上调用， 即使其值为 null，并且可以在函数体内检测 `this == null`，这能让你在没有检测 null 的时候调用 Kotlin 中的toString()：检测发生在扩展函数的内部

## 扩展属性

由于扩展没有实际的将成员插入类中，因此对扩展属性来说[幕后字段](https://www.kotlincn.net/docs/reference/properties.html#幕后字段)是无效的。这就是为什么**扩展属性不能有初始化器**。他们的行为只能由显式提供的 getters/setters 定义

## 伴生对象的扩展

## 扩展的作用域

大多数时候我们在顶层定义扩展——直接在包里

要使用所定义包之外的一个扩展，我们需要在调用方导入它

## 扩展声明为成员

在一个类内部你可以为另一个类声明扩展。在这样的扩展内部，有多个 *隐式接收者* —— 其中的对象成员可以无需通过限定符访问。扩展声明所在的类的实例称为 *分发接收者*，扩展方法调用所在的接收者类型的实例称为 *扩展接收者*

对于分发接收者与扩展接收者的成员名字冲突的情况，扩展接收者优先。要引用分发接收者的成员你可以使用 [限定的 `this` 语法](https://www.kotlincn.net/docs/reference/this-expressions.html#限定的-this)

声明为成员的扩展可以声明为 `open` 并在子类中覆盖。这意味着这些函数的分发对于分发接收者类型是虚拟的，但对于扩展接收者类型是静态的

## 关于可见性的说明