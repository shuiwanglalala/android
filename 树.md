# 树

+ 树的基本概念
  + n个节点的树只有n-1条边
  + 树中的节点数=所有节点的度数+1
  + 度为m的树中第i层至多有m[i-1]个节点 i>=1

+ 二叉树
  + 二叉树 VS 度为2的有序树
    + 二叉树可以为空，度为2的有序树至少有3个节点
    + 二叉树的孩子节点始终有左右之分，度为2的有序树的孩子节点次序是相对的
  + 特殊的二叉树
    + 满二叉树 高度为h，且含有2[h]-1个节点的二叉树
    + 完全二叉树 与满二叉树的编号一一对应（从上到下，从左到右编号）
    + 二叉排序树 对应任意节点t，若存在左子树/右子树，则左子树上所有节点小于t，右子树上所有节点均大于t
      + 中序遍历序列是递增的
      + 删除
        + 若被删除节点为叶子节点，则直接删除
      + 若被删除节点z只有一颗子树，则让z的子树成为z父节点的子树，代替z节点
        + 若被删除节点z有两颗子树，则让z的中序序列的直接后继替代z，并删除直接后继节点
        + 先删除z，再插入z，二叉树不一定发送变化
      + 查找效率 平均值是O(log2(n))
    + 平衡二叉树AVL 树上任意节点的左子树和右子树的深度不超过1
      + 高度h的最小平衡二叉树的节点数
        + N(h) = N(h-1)+N(h-2)+1
        + N(0)=0, N(1)=1
      + 插入时，每次调整最小的非平衡二叉树
    + 哈夫曼树 含有n个带权叶子节点带权路径长度最小的二叉树
  + 二叉树的性质
    + 非空二叉树的叶子树等于度为2的节点树加1 n0=n2+1
  
+ 二叉树的存储
  + 顺序存储 用一组连续的存储单元依次自上而下，自左而右存储完全二叉树的节点元素
    + 对于一般的二叉树，可通过补0存储，但会浪费空间
  + 链式存储
+ 二叉树的遍历
  + 层次遍历
  + 先/后/层次+中，可以确定一颗二叉树；先+后，不能确定一颗二叉树

+ 线索二叉树
  + 线索化
    + 若无左子树，则将左指针指向其前驱节点
    + 若无右子树，则将右指针指向其后继节点

+ 树、森林与二叉树
  + 树、森林与二叉树的转换
    + 树与二叉树的转换 每个节点左指针指向它的第一个孩子节点，右指针指向它在树中相邻兄弟节点
    + 森林与二叉树的转换 将每一棵树转换为二叉树，将每棵二叉树的根依次上一棵二叉树的右子树
  + 树、森林的遍历
    + 树的先根遍历序列与这颗树对应二叉树的先序遍历序列相同
    + 树的后根遍历序列与这颗树对应二叉树的中序遍历序列相同
    + 森林的先序遍历序列与这森林对应二叉树的先序遍历序列相同
    + 森林的中序遍历序列与这森林对应二叉树的中序遍历序列相同