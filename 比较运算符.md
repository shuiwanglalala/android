# 比较运算符

+ 概述
  + 比较运算符可以比较各种类型的值，不仅仅是数值
  + 对于非相等的比较，算法是先看两个运算子是否都是字符串，如果是的，就按照字典顺序比较（实际上是比较 Unicode 码点）；否则，将两个运算子都转成数值，再比较数值的大小
  + 相等的比较
+ 非相等运算符：字符串的比较
  + JavaScript 引擎内部首先比较首字符的 Unicode 码点。如果相等，再比较第二个字符的 Unicode 码点，以此类推
+ 非相等运算符：非字符串的比较
  + 如果两个运算子之中，至少有一个不是字符串
    + 如果两个运算子都是原始类型的值，则是先转成数值再比较
      + 这里需要注意与NaN的比较。任何值（包括NaN本身）与NaN比较，返回的都是false
    + 如果运算子是对象，会转为原始类型的值，再进行比较
      + 对象转换成原始类型的值，算法是先调用valueOf方法；如果返回的还是对象，再接着调用toString方法
+ 严格相等运算符
  + 如果两个值的类型不同，直接返回false
  + 同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回true，值不同就返回false
  + 两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个地址
  + undefined和null与自身严格相等
+ 严格不相等运算符
+ 相等运算符
  + 相等运算符用来比较相同类型的数据时，与严格相等运算符完全一样
  + 原始类型的值会转换成数值再进行比较
  + 对象（这里指广义的对象，包括数组和函数）与原始类型的值比较时，对象转换成原始类型的值，再进行比较
  + undefined和null与其他类型的值比较时，结果都为false，它们互相比较时结果为true
  + 相等运算符隐藏的类型转换，会带来一些违反直觉的结果
    + 因此建议不要使用相等运算符（==），最好只使用严格相等运算符（===）
+ 不相等运算符