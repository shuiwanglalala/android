# 泛型

[一文读懂 kotlin 的协变与逆变 -- 从 Java 说起](https://juejin.cn/post/6882360186641350664#heading-10)

https://rengwuxian.com/kotlin-generics/

两篇文章都不错



前面讲到了 Java 中单个 `?` 号也能作为泛型通配符使用，相当于 `? extends Object`。
它在 Kotlin 中有等效的写法：`*` 号，相当于 `out Any`

和 Java 不同的地方是，如果你的类型定义里已经有了 `out` 或者 `in`，那这个限制在变量声明时也依然在，不会被 `*` 号去掉

由于 Java 中的泛型存在类型擦除的情况，任何在运行时需要知道泛型确切类型信息的操作都没法用了。Kotlin中使用关键字 `reified` 配合 `inline` 来解决

两个 Kotlin 泛型与 Java 泛型不一致的地方

+ Java 里的数组是支持协变的，而 Kotlin 中的数组 `Array` 不支持协变。
  这是因为在 Kotlin 中数组是用 `Array` 类来表示的，这个 `Array` 类使用泛型就和集合类一样，所以不支持协变
+ Java 中的 `List` 接口不支持协变，而 Kotlin 中的 `List` 接口支持协变。
  Java 中的 `List` 不支持协变，原因在上文已经讲过了，需要使用泛型通配符来解决。
  在 Kotlin 中，实际上 `MutableList` 接口才相当于 Java 的 `List`。Kotlin 中的 `List` 接口实现了只读操作，没有写操作，所以不会有类型安全上的问题，自然可以支持协变

## 型变

### 声明处型变

在 Kotlin 中，有一种方法向编译器解释这种情况。这称为**声明处型变**：我们可以标注 `Source` 的**类型参数** `T` 来确保它仅从 `Source` 成员中**返回**（生产），并从不被消费。 为此，我们提供 **out** 修饰符

一般原则是：当一个类 `C` 的类型参数 `T` 被声明为 **out** 时，它就只能出现在 `C` 的成员的**输出**-位置，但回报是 `C` 可以安全地作为 `C`的超类

简而言之，他们说类 `C` 是在参数 `T` 上是**协变的**，或者说 `T` 是一个**协变的**类型参数。 你可以认为 `C` 是 `T` 的**生产者**，而不是 `T` 的**消费者**

**out**修饰符称为**型变注解**，并且由于它在类型参数声明处提供，所以我们称之为**声明处型变**。 这与 Java 的**使用处型变**相反，其类型用途通配符使得类型协变

## 类型投影

### 使用处型变：类型投影

```kotlin
fun copy(from: Array<out Any>, to: Array<Any>) { …… }
```

这里发生的事情称为**类型投影**：我们说`from`不仅仅是一个数组，而是一个受限制的（**投影的**）数组：我们只可以调用返回类型为类型参数 `T` 的方法，如上，这意味着我们只能调用 `get()`。这就是我们的**使用处型变**的用法，并且是对应于 Java 的 `Array`、 但使用更简单些的方式

### 星投影？？

## 泛型函数

不仅类可以有类型参数。函数也可以有。类型参数要放在函数名称**之前**

要调用泛型函数，在调用处函数名**之后**指定类型参数即可

可以省略能够从上下文中推断出来的类型参数

## 泛型约束

能够替换给定类型参数的所有可能类型的集合可以由**泛型约束**限制

### 上界

默认的上界（如果没有声明）是 `Any?`。在尖括号中只能指定一个上界。 如果同一类型参数需要多个上界，我们需要一个单独的 **where**-子句

## 类型擦除

Kotlin 为泛型声明用法执行的类型安全检测仅在编译期进行。 运行时泛型类型的实例不保留关于其类型实参的任何信息。 其类型信息称为被*擦除*

因此，并没有通用的方法在运行时检测一个泛型类型的实例是否通过指定类型参数所创建 ，并且编译器[禁止这种 *is* 检测](https://www.kotlincn.net/docs/reference/typecasts.html#类型擦除与泛型检测)

泛型函数调用的类型参数也同样只在编译期检测。在函数体内部， 类型参数不能用于类型检测，并且类型转换为类型参数（`foo as T`）也是非受检的。然而， 内联函数的[具体化的类型参数](https://www.kotlincn.net/docs/reference/inline-functions.html#具体化的类型参数)会由调用处内联函数体中的类型实参所代入，因此可以用于类型检测与转换， 与上述泛型类型的实例具有相同限制