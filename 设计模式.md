# 设计模式面试

+ [面向对象六大原则和设计模式](https://itsmelo.github.io/2016/11/20/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E5%92%8C%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/)
+ 单一职责原则
  + 类的复杂性降低，实现什么职责都有清晰明确的定义
  + 可读性提高，复杂性降低，那当然可读性提高了
  + 可维护性提高，可读性提高了，那当然更容易维护了
  + 变更引起的风险降低，变更是必不可少的，如果接口的单一职责做得好，一个接口修改只对应的实现类有影响，对其他的接口无影响，这对系统的扩展性、维护性都有非常大的帮助
  + mvp中p将UI logic从v中释放

+ 里式替换原则

  + 面向对象的语言的三大特点是继承、封装、多态，里氏替换原则就是依赖于继承、多态这两大特性。里氏替换原则简单来说就是所有引用基类、接口的地方必须能透明地使用其子类的对象。通俗点讲，只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何报错或者异常，使用者可能根本就不需要知道是子类还是父类。但是，反过来就不行了，有子类出现的地方，父类未必就能使用
  + 优点
    + 代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性
    + 提高代码的重用性
    + 提高代码的可扩展性，实现父类的方法就可以“为所欲为”了，很多开源框架的扩展接口都是通过继承父类来完成的
    + 提高产品或项目的开放性

  + 缺点
    + 继承是侵入性的。只要继承，就必须拥有父类所有的属性和方法
    + 降低了代码的灵活性。子类必须继承父类的属性和方法，让子类自由的世界中多了些约束
    + 增强了耦合性。当父类的常量、变量和方法被修改时，必须要考虑子类的修改，而且在缺乏规范的环境下，这种修改可能带来非常糟糕的后果—大量的代码需要重构
  + 鼓励你使用接口，java中的接口自动实现了该原则

+ 依赖倒置原则

  + 高层模块不应该依赖底层模块，两者都应该依赖其抽象
  + 抽象不应该依赖细节
  + 细节应该依赖抽象
  + 优点
    + 可扩展性好
    + 耦合度低
  + 仓库模式 contentprovider

+ 开闭原则

  + 一个软件实体类，模块和函数应该对扩展开放，对修改关闭
  + 开闭原则与依赖倒置原则，里氏替换原则一样，实际上都遵循一句话：面向接口编程
  + 优点
    + 增加稳定性
    + 可扩展性高

+ 接口隔离原则
  + 一个类对另一个类的依赖应该建立在最小的接口上。根据接口隔离原则，当一个接口太大时，我们需要把它分离成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可
  + 优点
    + 降低耦合性
    + 提升代码的可读性
    + 隐藏实现的细节
  + treemap继承sortmap，sortmap的key需要实现comparable接口
+ 迪米特原则
  + 一个对象应该对其他对象有最少的了解。通俗地讲，一个类应该对自己需要耦合或者调用的类知道得最少，这有点类似于接口隔离原则中的最小接口的概念。类的内部如何实现、如何复杂都与调用者或者依赖者没有关系，调用者或者依赖者只需要知道它需要它需要的方法即可，其他的一概不关心。类与类之间的关系越密切，耦合度越大，当一个类发生改变时，对另一个类的影响也越大
  + 优点
    + 降低复杂度
    + 降低耦合性
    + 增加稳定性
  + fragment需要调用宿主activity，最好activity实现一个接口，注入到fragment中，而不是直接调用fragment.getActivity()